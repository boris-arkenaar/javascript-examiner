\documentclass{article} 
\usepackage{thesis-config}

\include{front-back/glossary}

\begin{document} 

\title{Using a design recipe to teach JavaScript code}
\author{Ronald Kluft (838812818)} 
\date{\today \\version 1.0} \maketitle 


\bibliographystyle{apalike}
\bibliography{bibliography}

\section{Introduction}

This paper is the result of a short but intensive domain study on the structure
of the design recipe of a program or function.
It is part of the JavaScript-examiner\footnote{\url{https://github.com/Slotkenov/JavaScript-examiner/}} project.
This project is intended to make an interactive learning environment for students
to learn the JavaScript language. 
In the course {\em Webapplications: The Client Side} of the Open Universiteit,
the student is encouraged to use the design recipe which is mainly borrowed from
the online course {\em Introduction to Systematic Program Design - Part 1}
of the University of British Colombia, by prof. Gregor Kiczales
\footnote{\url{http://https://www.coursera.org/course/programdesign}},
and based on chapter 3.1 of the book Designing Functions of the 2nd edition of the book
'How to Design Programs' by Felleisen, Findler, Flatt and Krishnamurthi
\footnote{\url{http://www.ccs.neu.edu/home/matthias/HtDP2e/}}.
In this paper I have chosen to take the second, with writing in progress, version.
I will refer to them as [WAC], [Coursera] and [HtDP], for brevity.

In the description I mainly use the term function, because this is mostly
the structure that will be described, but the recipe isn't restricted to this
structure.

In this paper I will summarize the steps, and the possibility of usage in the 
JavaScript-examiner.

I will conclude with recommendations how to expand the usage of the recipe in
the [WAC], for instance with the use of comment.
The checking of elegant JavaScript is discussed in [Arkenaar, 2014], and will
not be part of this paper.
Also I will not deepening the feedback on solution [Nieuwenhuize, 2014], although
it will be mentioned where appropriate.

I will also look into the way the recipe is included in the code files.

The study of [Bieniusa et.al., 2008] also mentions the fact that their students often copy code from
each other, thus making them guilty of plagiarism.
In this paper I won't go deeper into this subject.


\subsection{Context}

The JavaScript-examiner is a tool to examine submitted exercises from students
of the OU who participate in the course [WAC].
The purpose of the tool is two-folded : it will  reduce the workload of the
tutor, and let the student anonymously submit solutions to take away possible
fear of having degraded by wrong answers.

In chapter 6 of [WAC] the use of a design recipe is introduced. A number of rules
are given to which the student should apply, in order to use the recipe to learn
to program in a stepwise manner, where the previous step is used in the following.
Where [HtDP] and [Coursera] are focussing on the Beginning Student Language
(BSL) of the Dr.Racket programming environment, [WAC] is focussing on JavaScript.
In the subsequent steps, the general concept will be explained, and if applicable,
be matched with JavaScript.
The intention is to learn the recipe with simple functions, and then use the
recipe to design harder functions.

The JavaScript-examiner accepts complete solutions from the students and gives proper
feedback on the submitted code, if necessary, to help the student gain the
required skills. To promote the usage of the design recipe, the steps it contains
should be part of the solution the student submits.


\section{Recipe}
The design recipe discussed in [HtDP] consists of 6 steps, where the version of
[Coursera] has 5 steps.

There is a difference between the various recipes, but I will name them if they occur.
The recipe is like a top-down structure. The step at hand is helped by the step
before, and helps with the step after it.
This can be helpful in checking the recipe, because for instance, the names of
the function has to be the same as in the step before, and also the number of
arguments. This can also help in determining which feedback has to be given back
to the student.


Between version 1 and version 2 of [HtDP], there is a difference.
In version 1 there are 5 phases, and in the accompanying table there are even
as much as 4 phases (with Contract, Purpose and Header combined).
In the 2nd edition of HtDP, there are 6 phases.
I will exemplify the 2nd version, because this is the latest.

\begin{enumerate}
 \item Express how you wish to represent information as data.
 \item Write down a signature, a purpose statement, and a function header.
 \item Illustrate the signature and the purpose statement with some functional examples.
 \item Take inventory, to understand what are givens and what we do need to compute.
 \item Replace the body of the function with an expression that attempts to compute from the pieces in the template what the purpose statement promises.
 \item Test the function on the examples that you worked out before.
\end{enumerate}
 
 The first item is not included in the [Coursera] version of the recipe
 \footnote{\url{https://class.coursera.org/programdesign-002/wiki/view?page=HtDFunctions}}:
 
\begin{enumerate}
  \item (1) Signature, purpose and stub.
  \item (2) Define examples, wrap each in check-expect.
  \item (3) Template and inventory.
  \item (4) Code the function body.
  \item (5) Test and debug until correct.
\end{enumerate}

I will take the 6 steps of the [HtDP] version to elaborate them.

\subsection{Express how you wish to represent information as data}
This step is merely a one sentence summary of the exercise. It has no
extra usage to the explanation of the students work. It will only lead to more
logic on checking this text, because there can be a great number of varieties.
[Ramsey, 2014] splits this step into two parts: Data definition and Data example.
His students often forgot to write data examples, and he states that
"Data examples enjoy no comparable support."
One possibility could be the check on a single line, but examination of the
content could be overhead.


\subsection{Write down a signature, a purpose statement, and a function header}
In this step the student has to give the data types that are consumed and produced
by the function.
It should reflect the number of arguments the function expects and what type it
returns.
In the first, simple functions, the data types will be the standard built-in
data types. But as the functions get more complex, the data types can get more
complex as well.
In [WAC] (LE6, 1.6) the construction of more complex types is explained.
The JavaScript-examiner could check the number of arguments and names of the
data types. As the signatures get more complex, the exact names don't have to
match, only the number and the location in the signature. A simple test that
can be performed, is to test whether a constructor starts with a capital letter.

The purpose statement is a single line which states what the output of the
function is, in terms of the input. This should be a single line, and can be
matched to the standard line supplied by the tutor.
The student solution could be saved to match with other students submissions,
thus enhancing the tool.
Writing good purpose statements is very hard [Ramsey, 2014].
To test this in an automated way can be hard as well, and can be subject of
another study. The JavaScript-examiner should test for the fact that it is only
one statement, and match it with the tutor's standard solution. The student's
submission can also be saved, for checking against other submissions.


The function header [HtDP] or stub [Coursera] is the actual header of the
function to write. This should be exactly the same as the function header in the
submitted code.
This can be checked and saved by the JavaScript-examiner, to give feedback about
the consistency of the header.
Its purpose is to give the name of the function, as well as the type of data it
expects as its input.

The tutor can supply a standard header for an exercise, but to match it exactly
can be hard, because the student may not use the exact same name for the
function and its parameters.


\subsection{Illustrate the signature and the purpose statement with some functional examples}

The use of functional examples is to uniquely identify the purpose of the
function.
It is a good idea to let the students give some functional examples in a way
they can also be used to test the function.

[WAC] uses the libraries Mocha\footnote{\url{http://mochajs.org/}} and
Chai\footnote{\url{http://chaijs.com/}} to test the software.
The students have to write their tests in the assert style of Mocha.
These tests can be used to test their work to before submitting their solution
to the JavaScript-examiner.
The number of examples can be counted and the students can be given feedback if
there are too few examples or too much.


\subsection{Take inventory, to understand what are givens and what we do need to compute}

The purpose of this step is to take the signature, and create a simple body,
where only the return value is given.
It doesn't compute anything, but gives the framework for the actual
implementation of the function.
In the JavaScript-examiner, this can also be checked against the signature, and
it can be determined whether the function needs a return value or not, and if it
is the right return value. The body of the function is simplified, and can be
filled with pseudo code.
To check this can be a challenge, because of the diversity of statements. An
important thing is to distillate the return type.
Again, this could generate useful feedback for the student.


\subsection{Replace the body of the function with an expression that attempts to compute from the pieces in the template what the purpose statement promises}

This is the actual implementation of the function.
This should not be part of the recipe section in the submitted code, but be the
actual submitted solution.
The checking of this code in this section is the main function of the
JavaScript-examiner.


\subsection{Test the function on the examples that you worked out before}

The submitted code should pass all the tests that are part of the solution. It
also should pass the tests that are submitted by other students and have been
evaluated as useful.

If there is a test that fails, appropriate feedback should be returned. 

The tests that are submitted by the students can also be used to test the 
submissions of other students. This way the library with available tests for a
given exercise can be enriched.
The tutor can supply standard tests. He can also keep track of the tests
submitted by other students to look for duplicates.
Also the tutor has to supply a standard solution to run the tests against, to
check whether the test written by the students are correct.
Tests that do not have the correct outcome against the standard solution, are
not added to the test set.
Learning how to write tests is part of [WAC], but is not further discussed in
this paper.

\section{Conclusion}

While there are a lot of on-line initiatives for learning a programming language,
I have not came across one that uses a clearly recognizable design recipe.
[HtDP] and [Coursera] do use a design recipe, but they use it in the Dr. Racket
environment, though more as a guide line.
The JavaScript-examiner should have the recipe, commented out, as part of the
submitted solution. Because the comment is not part of the Abstract Syntax Tree,
it will have to be checked in an other way.
If it can be included, this could be a requirement to pass the exercise.
Both have to be analysed further, because it can also lead to reluctance to use
the examiner, but this can be subject of an other study.

It will require some effort of the tutor, to keep the list of tests clean.

At first, students may feel that they are doing a lot of work, for relatively
small function. But the goal should be learning the design recipe.
The JavaScript-examiner is a good means to do this.
A requirement should be that the tool generates proper feedback, 

This way, it can be an enhancement of learning the recipe, and thus, learning
the student to program better/make better functions.


\subsection{References}
[1]	Felleissen,
www.css.neu.edu/home/matthias/HtDP2e/

[2]	Coursera

www.htdp.org (septeber 2003 version)
second edition (a completely revised version, with writing in progress)


[3] Ramsey, Norman - [On teaching how to design programs]
To appear in Proceedings of the 2014 ACM SIGPLAN International Conference on Functional Programming (ICFP'14)
On Teaching How to Design Programs
Observations from a Newcomer
Department of Computer Science, Tufts University
nr@cs.tufts.edu


[4]	HtDP and DMdA in the Battlefield
A Case Study in First-year Programming Instruction
Annette Bieniusa
Markus Degen
Phillip Heidegger
Peter Thiemann
Stefan Wehr
Albert-Ludwigs-Universitat Freiburg
{bieniusa,degen,heidegger,thiemann,wehr}
@informatik.uni-freiburg.de
Martin Gasbichler
Zuhlke Engineering AG
martin.gasbichler@zuehlke.com
Marcus Crestani
Herbert Klaeren
Eric Knauel
Eberhard-Karls-Universitat Tubingen
{knauel,crestani,klaeren}
@informatik.uni-tuebingen.de
Michael Sperber
DeinProgramm
sperber@deinprogramm.de

FDPEâ€™08, September 21, 2008, Victoria, BC, Canada.
Copyright 
c 2008 ACM 978-1-60558-068-5/08/09. . .


Introduction to Systematic Program Design
https://www.coursera.org/course/programdesign



\printglossaries

\end{document} 
